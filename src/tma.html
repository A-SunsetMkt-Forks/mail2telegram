<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>mail2telegram</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@telegram-apps/sdk@1.1.3/dist/index.iife.js"></script>
    <link href="https://unpkg.com/boltcss/bolt.min.css" rel="stylesheet">
    <style>
        body {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }

        table {
            width: 100%;
        }

        th,
        td {
            text-align: left;
        }

        th:last-child,
        td:last-child {
            width: 80px;
            text-align: center;
        }

        button {
            padding: 5px 10px;
            min-width: 80px;
        }

        .growContainer {
            display: flex;
            align-items: center;
        }

        .growItem {
            max-width: 100%;
            flex-grow: 1;
        }
    </style>
</head>

<body>
<div id="app">
    <h3 class="growContainer">
        List Mode
        <select class="growItem" style="margin-left: 10px;" v-model="mode">
            <option value="block">Block list</option>
            <option value="white">White list</option>
            <option value="test">Test address</option>
        </select>
    </h3>
    <p v-if="tipMessage">{{ tipMessage }}</p>
    <table>
        <thead>
        <tr>
            <th>address</th>
            <th>{{ mode === 'test' ? 'type' : 'action' }}</th>
        </tr>
        </thead>
        <tbody v-if="mode!=='test'">
        <tr>
            <td class="growContainer">
                <input :placeholder="inputPlaceholder" class="growItem" v-model="inputAddress">
            </td>
            <td>
                <button @click="addAddress">Add</button>
            </td>
        </tr>
        <tr :key="index" v-for="(address, index) in addresses">
            <td>{{ address }}</td>
            <td>
                <button @click="removeAddress(index)">Delete</button>
            </td>
        </tr>
        </tbody>
        <tbody v-else>
        <tr>
            <td class="growContainer">
                <input :placeholder="inputPlaceholder" class="growItem" v-model="inputAddress">
            </td>
            <td>
                <button @click="testAddress">Test</button>
            </td>
        </tr>
        <tr :key="index" v-for="(item, index) in addresses">
            <td>{{ item.address }}</td>
            <td>{{ item.result }}</td>
        </tr>
        </tbody>
    </table>
</div>

<script>
  const {createApp, computed, ref, onMounted, watch} = Vue;


  const addAddress = async (address, type, tma) => {
    return fetch('/api/address/add', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `tma ${tma}`,
      },
      body: JSON.stringify({
        address,
        type,
      }),
    });
  };

  const removeAddress = async (address, type, tma) => {
    return fetch('/api/address/remove', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `tma ${tma}`,
      },
      body: JSON.stringify({
        address,
        type,
      }),
    });
  };

  const loadAddress = async (tma) => {
    return fetch('/api/address/list', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `tma ${tma}`,
      },
    });
  };

  createApp({
    setup() {

      const urlParams = new URLSearchParams(window.location.search);

      const blockList = ref([]);
      const whiteList = ref([]);
      const testList = ref([]);
      const tipMessage = ref('');
      const inputAddress = ref('');
      const mode = ref(urlParams.get('mode') || 'block');
      const tmaParams = ref(null);

      const addresses = computed(() => {
        switch (mode.value) {
          case 'block':
            return blockList.value;
          case 'white':
            return whiteList.value;
          case 'test':
            return testList.value;
        }
      });

      const inputPlaceholder = computed(() => {
        switch (mode.value) {
          case 'block':
            return 'New block address regex';
          case 'white':
            return 'New white address regex';
          case 'test':
            return 'Test address';
        }
      });

      const addAddress = async () => {
        if (!inputAddress.value) {
          return;
        }
        const value = inputAddress.value.trim();
        await addAddress(value, mode.value, tmaParams.value);
        inputAddress.value = '';
        switch (mode.value) {
          case 'block':
            blockList.value.push(value);
            break;
          case 'white':
            whiteList.value.push(value);
            break;
          case 'test':
            break;
        }
      };

      const removeAddress = (index) => {
        const value = addresses.value[index];
        removeAddress(value, mode.value, tmaParams.value);
        switch (mode.value) {
          case 'block':
            blockList.value.splice(index, 1);
            break;
          case 'white':
            whiteList.value.splice(index, 1);
            break;
          case 'test':
            break;
        }
      };

      const testAddress = () => {
        const test = [];
        const value = inputAddress.value.trim();
        for (const item of blockList.value) {
          console.log(`item: ${item}, value: ${value}`);
          if (new RegExp(item).test(value)) {
            test.push({
              address: item,
              result: 'block',
            });
          }
        }
        for (const item of whiteList.value) {
          console.log(`item: ${item}, value: ${value}`);
          if (new RegExp(item).test(value)) {
            test.push({
              address: item,
              result: 'white',
            });
          }
        }
        testList.value = test;
      };

      watch(mode, () => {
        inputAddress.value = '';
      });


      onMounted(async () => {
        try {
          const {initDataRaw} = window.telegramApps.sdk.retrieveLaunchParams();
          tmaParams.value = initDataRaw;
          const response = await loadAddress(initDataRaw);
          const {block, white, error} = await response.json();
          blockList.value = block;
          whiteList.value = white;
          tipMessage.value = error;
        } catch (error) {
          tipMessage.value = error.message;
        }
      });

      return {
        addresses,
        tipMessage,
        inputAddress,
        inputPlaceholder,
        mode,
        addAddress,
        removeAddress,
        testAddress,
      };

    },
  }).mount('#app');
</script>
</body>

</html>
